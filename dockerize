#!/bin/bash
# Make it easy to run development activity out of a container.
# Whereever you install this as "dockerize" that is where it will create its links.
# trampoline should be installed to the same location

# call as get_environment_$(uname -s)
get_environment_Darwin() {
	local env
	env=$(ps -wwE -p $PPID); env="${env#$(ps -ww -p $PPID)} SHLVL=.* _=.* PATH=.* PWD=.*"
	env | grep -x -v -f <(echo ${env} | tr ' ' "\n")
}

docker_tty='-i'
[ -c /dev/fd/0 ] && docker_tty='-it'
pinata=$(docker ps -qf name=pinata-sshd)
test -z "$pinata" -o ! -f ~/.pinata-sshd/known_hosts && pinata-ssh-forward
command=$(basename $0)
bindir=$(dirname $0)
container=$(readlink $0)
trampoline=${bindir}/trampoline
container=${container:-$command}
containerpath=${bindir}/$container
case $command in
	with)
		command=""
		container=$1
		shift
		;;
	dockerize)
		# Usage
		if [ $# -lt 1 ]; then
			cat <<-EOT >&2
			Usage: dockerize <container> [<command>]...
			       dockerize upgrade
			if container == command then no further arguments are necessary.
			EOT
		fi
		container=$1
		if [ "$container" = "upgrade" ]; then
			# Self upgrade
			currentinode=$(ls -i ${bindir}/dockerize | cut -f1 -d' ')
			test -d ${bindir}/.dockerize.git || \
			  git clone --mirror git@github.com:FutureAdvisor/dockerize ${bindir}/.dockerize.git
			git --git-dir ${bindir}/.dockerize.git fetch --prune
			if diff <(git --git-dir ${bindir}/.dockerize.git show master:dockerize) $0 >/dev/null; then
				echo "up to date"
			else
				git --git-dir ${bindir}/.dockerize.git show master:dockerize > $0
				newinode=$(ls -i ${bindir}/dockerize | cut -f1 -d' ')
				if [ "$newinode" -ne "$currentinode" ]; then
					for file in $(find ${bindir} -inum $currentinode -a ! -name dockerize); do
						rm $file
						ln ${bindir}/dockerize $file
					done
				fi
				exec "$0" "$@"
			fi
		else
			# Install new software
			shift
			test ! -e ${bindir}/${container} && ln ${containerpath} ${bindir}/${container}
			for cmd in "$@"; do
				test ! -e ${bindir}/${cmd} && ln -s ${container} ${bindir}/${cmd}
			done
		fi
		exit 0
esac
if [ ! -x "$(which realpath)" ]; then
  echo "realpath not installed: brew install coreutils"
  exit 1
fi

# Attempt to find a file in parent directories or the home directory.
# we use this to locate eg. .ruby-version
loadup() {
  path="$(pwd)"; while [ -n "${path}" -a ! -e "${path}/$1" ]; do path="${path%/*}"; done
  test -z "${path}" -a -e "${HOME}/$1" && path="${HOME}"
  test -n "${path}" && echo -n "$(<${path}/$1)"
}

clean_container=${container//\//__}
container_version="$(loadup .$(basename ${container})-version)"
container_version="${container_version#$(basename ${container})-}"
container_version="${container_version:-latest}"

container_volumes="-v $HOME:$HOME -v ~/.ssh/known_hosts:/etc/ssh/ssh_known_hosts $(pinata-ssh-mount) -v ${trampoline}:/bin/trampoline:ro"
environment=''
test -f ${containerpath}.defaults && . ${containerpath}.defaults
container_volumes=$(eval echo $container_volumes)
instance=$(docker ps -qf name=${clean_container}_${container_version} | head -1)
if [ -z "$instance" ]; then
	cleanup=$(docker rm ${clean_container}_${container_version} 2>/dev/null)
	instance=$(docker run -td $container_volumes $environment --name ${clean_container}_${container_version} $container:$container_version cat)
fi
env=$(get_environment_$(uname -s))
docker exec ${docker_tty} $instance /bin/execwdve ${env} "${PWD}" $command "$@"
